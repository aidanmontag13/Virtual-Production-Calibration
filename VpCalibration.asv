% Import images and Extract Color Patches
colorCheckerPath = 'images/CC_resolve.tif';
imaged_colorCheckerPath = 'images/Imaged_CC.tif';

%rgbValues = extractColorCheckerRGB(colorCheckerPath);
%imaged_rgbValues = extractColorCheckerRGB(imaged_colorCheckerPath);

% Compensate for exposure difference in two images
linearized_greyscale_white = rgbValues(19,2) .^ 2.4; % Find the linear CV for the digital CC white patch
linearized_greyscale_black = rgbValues(24,2) .^ 2.4; % Find the linear CV for the digital CC white patch
linearized_imaged_rgbValues = imaged_rgbValues .^ 2.4; % Convert the imaged CC to linear
linearized_imaged_greyscale_white = linearized_imaged_rgbValues(19,2); % Find the linear CV for the imaged CC white patch
linearized_imaged_greyscale_black = linearized_imaged_rgbValues(24,2); % Find the linear CV for the imaged CC black patch
linear_scale_factor = linearized_greyscale_white / linearized_imaged_greyscale_white; % Create scale factor based on white patches
linear_offset_factor = linearized_imaged_greyscale_black - linearized_greyscale_black; % Create offset factor based on black patches
offset_corrected_linear_imaged_rgbValues = linearized_imaged_rgbValues - linear_offset_factor; % Apply offset to minimize impact of flair
offset_corrected_linear_imaged_rgbValues = max(0, min(1, offset_corrected_linear_imaged_rgbValues)); % Clamp
exposure_corrected_linear_imaged_rgbValues = offset_corrected_linear_imaged_rgbValues * linear_scale_factor; % Scale imaged CC to digital CC
exposure_corrected_imaged_rgbValues = exposure_corrected_linear_imaged_rgbValues .^ (1/2.4); % Return to 2.4 gamma

% linearize greyscale for each channel
greyscale = rgbValues(19:24, :);
imaged_greyscale = exposure_corrected_imaged_rgbValues(19:24, :);

output_r = greyscale(:, 1);
input_r = imaged_greyscale(:, 1);

output_g = greyscale(:, 2);
input_g = imaged_greyscale(:, 2);

output_b = greyscale(:, 3);
input_b = imaged_greyscale(:, 3);

% Create 1D Lut with R,G,B using p chip interpolation
xq = linspace(0, 1, 33);
r_lut = interp1(input_r, output_r, xq, 'pchip');
g_lut = interp1(input_g, output_g, xq, 'pchip');
b_lut = interp1(input_b, output_b, xq, 'pchip');

% Alternativly Apply Green Lut in every channel

% Clamp 0-1
r_lut = max(0, min(1, r_lut));
g_lut = max(0, min(1, g_lut));
b_lut = max(0, min(1, b_lut));

% Plot 1D Luts
figure (1);
clf;
hold on;

plot(r_lut, 'Color', [1 0 0], 'LineWidth', 2); % red
plot(g_lut, 'Color', [0 1 0], 'LineWidth', 2); % green
plot(b_lut, 'Color', [0 0 1], 'LineWidth', 2); % blue

xlabel('Input Index');
ylabel('Output Value');
title('1D LUTs');
grid on;
hold off;

% Apply 1D Luts to imaged CC CVs
imaged_rgbValues_r = exposure_corrected_imaged_rgbValues(:,1); % Seperate R,G,B Channels
imaged_rgbValues_g = exposure_corrected_imaged_rgbValues(:,2);
imaged_rgbValues_b = exposure_corrected_imaged_rgbValues(:,3);

imaged_rgbValues_r = max(0, min(1, imaged_rgbValues_r)); % Clamp
imaged_rgbValues_g = max(0, min(1, imaged_rgbValues_g));
imaged_rgbValues_b = max(0, min(1, imaged_rgbValues_b));

corrected_imaged_rgbValues_r = interp1(xq, r_lut, imaged_rgbValues_r, 'linear'); %Apply Luts
corrected_imaged_rgbValues_g = interp1(xq, g_lut, imaged_rgbValues_g, 'linear');
corrected_imaged_rgbValues_b = interp1(xq, b_lut, imaged_rgbValues_b, 'linear');

% Combine back into triplets
greyscale_corrected_imaged_rgbValues = [corrected_imaged_rgbValues_r, corrected_imaged_rgbValues_g, corrected_imaged_rgbValues_b];

% Create 3x3 Matrix using Fmincon
x0 = randn(9,1); % initial guess (9 parameters = 3x3)

%x0 = [1 0 0 0 1 0 0 0 1];

options = optimoptions('fmincon','Display','iter','Algorithm','interior-point');

objfun = @(x) costFunction(x, greyscale_corrected_imaged_rgbValues(1:24,:), rgbValues(1:24,:));

[xopt, fval] = fmincon(objfun, x0, [], [], [], [], [], [], [], options);

% Reshape result into 3x3 matrix
M_opt = reshape(xopt, [3,3]);

disp('Optimized 3x3 matrix:');
disp(M_opt);

% Apply 3x3 matrix to evaluate
matrix_test = greyscale_corrected_imaged_rgbValues * M_opt';

disp("Average Original Error")
(mean(abs(exposure_corrected_imaged_rgbValues - rgbValues))) .* 255

disp("Average Error with 1D Luts")
(mean(abs(greyscale_corrected_imaged_rgbValues - rgbValues))) .* 255

disp("Average Error with Matrix")
(mean(abs(matrix_test - rgbValues))) .* 255

% Create 3D Lut with 3x3 Matrix
N = 33;
LUT3D = zeros(N,N,N,3);

for r = 1:N
    for g = 1:N
        for b = 1:N
            RGBTriplet = [r,g,b] / N;
            CalibratedRGBTriplet = RGBTriplet * M_opt';
            LUT3D(r,g,b,:) = CalibratedRGBTriplet;
        end
    end
end

N = 16;
LUT3D_UE = zeros(N,N,N,3);

for r = 1:N
    for g = 1:N
        for b = 1:N
            R = r / N;
            G = g / N;
            B = b / N;
            R = interp1(xq, r_lut, R, 'linear');
            G = interp1(xq, g_lut, G, 'linear');
            B = interp1(xq, b_lut, B, 'linear');
            RGBTriplet = [R,G,B];
            CalibratedRGBTriplet = RGBTriplet * M_opt';
            %CalibratedRGBTriplet = RGBTriplet;
            LUT3D_UE(r,g,b,:) = CalibratedRGBTriplet;
        end
    end
end

% Plot 3D Lut
plot3DLUT(LUT3D_UE)

% Save in .cube format
cubepath = "outputs/VpCalibration.cube";
texturepath = "outputs/VpCalibration_lut.tiff";

exportCube(cubepath, r_lut, g_lut, b_lut, LUT3D)

Save3DLUTasTexture(LUT3D_UE, texturepath)

% import test image
img = im2double(imread(imaged_colorCheckerPath));
img2 = im2double(imread(colorCheckerPath));

[h, w, ~] = size(img);

% Apply 3x3 matrix and 1D luts
reshaped = reshape(img, [], 3);          % N x 3 (rows = pixels)
reshaped = ((reshaped .^ (2.4)) * linear_scale_factor) .^ (1/2.4);
reshaped = max(0, min(1, reshaped));
reshaped(:,1) = interp1(xq, r_lut, reshaped(:,1), 'linear');
reshaped(:,2) = interp1(xq, g_lut, reshaped(:,2), 'linear');
reshaped(:,3) = interp1(xq, b_lut, reshaped(:,3), 'linear');
corrected = reshaped * M_opt.';          % apply 3x3 color correction
corrected = max(0, min(1, corrected));   % clamp to [0,1]
corrected_img = reshape(corrected, h, w, 3);

f = figure(3);
set(f, 'Name', 'Color Checker', 'NumberTitle', 'off');
clf(f);

% Show original image
subplot(1,3,1);          % 1 row, 2 columns, first plot
imshow(img);     % replace with your original image variable
title('Original Image');

% Show original colorchecker
subplot(1,3,2);          % 1 row, 2 columns, second plot
imshow(img2);     % replace with your original image variable
title('Original Color Checker');

% Show imaged colorchecker with correction
subplot(1,3,3);          % 1 row, 3 columns, third plot
imshow(corrected_img);
title('Corrected Image');









